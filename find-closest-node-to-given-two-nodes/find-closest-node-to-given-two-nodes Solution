class   Solution   { 
  public : 
      int   closestMeetingNode ( vector < int > &  edges ,   int  node1 ,   int  node2 )   { 
         unordered_map < int ,   int >  m1 ; 
         unordered_map < int ,   int >  m2 ; 
          int  n = edges . size ( ) ; 
         vector < bool >   vis ( n , false ) ; 
          int  n1 = node1 ,  n2 = node2 ; 
          int  dist = 1 ; 
         m1 [ n1 ] = 0 ; 
         m2 [ n2 ] = 0 ; 
         vis [ n1 ] = true ; 
          while ( edges [ n1 ] != - 1   &&  vis [ edges [ n1 ] ] == false ) { 
             vis [ edges [ n1 ] ] = true ; 
             m1 [ edges [ n1 ] ] = dist ; 
             n1 = edges [ n1 ] ; 
             dist ++ ; 
          } 
         dist = 1 ; 
         vector < bool >   vis2 ( n ,   false ) ; 
         vis2 [ n2 ] = true ; 
          while ( edges [ n2 ] != - 1    &&   vis2 [ edges [ n2 ] ] == false ) { 
             vis2 [ edges [ n2 ] ] = true ; 
             m2 [ edges [ n2 ] ] = dist ; 
             n2 = edges [ n2 ] ; 
             dist ++ ; 
          } 
          int  answer = INT_MAX ; 
          int  mn = INT_MAX ; 
          for ( auto   & x : m1 ) { 
              int  node = x . first ; 
              if ( m2 . find ( node ) != m2 . end ( ) ) { 
                  if ( mn  ==   max ( x . second , m2 [ node ] ) ) 
                     answer = min ( answer ,  node ) ; 
                  else   if ( mn  >   max ( x . second , m2 [ node ] ) ) { 
                     answer = node ; 
                     mn = max ( x . second , m2 [ node ] ) ; 
                  } 
              } 
          } 
          if ( answer == INT_MAX ) 
              return   - 1 ; 
          return  answer ; 
      } 
  } ;