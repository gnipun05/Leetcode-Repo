// this is Map Solution (Efficient Approach but hard to think) 
 // previous accepted solution was Priority Queue Solution (Easy to think, but Inefficient {though accepted}) 
 class   Solution   { 
 public : 
      int   leastInterval ( vector < char > &  tasks ,   int  n )   { 
         unordered_map < char , int > mp ; 
          int  count  =   0 ; 
          for ( auto  e  :  tasks ) 
          { 
             mp [ e ] ++ ; 
             count  =   max ( count ,  mp [ e ] ) ; 
          } 
         
          int  ans  =   ( count - 1 ) * ( n + 1 ) ; 
          for ( auto  e  :  mp )   if ( e . second  ==  count )  ans ++ ; 
          return   max ( ( int ) tasks . size ( ) ,  ans ) ; 
      } 
 } ;